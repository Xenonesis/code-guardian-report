/**
 * Dependency Vulnerability Scanner
 * Scans project dependencies for known vulnerabilities using multiple databases
 * Supports multiple package managers and provides detailed vulnerability information
 */

export interface VulnerabilityDatabase {
  name: string;
  url: string;
  lastUpdated: Date;
  totalVulnerabilities: number;
}

export interface PackageInfo {
  name: string;
  version: string;
  ecosystem: string;
  description?: string;
  license?: string;
  homepage?: string;
  repository?: string;
  maintainers?: string[];
  downloads?: number;
  publishedDate?: Date;
  deprecated?: boolean;
}

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  cvss: {
    version: string;
    score: number;
    vector: string;
    baseScore: number;
    temporalScore?: number;
    environmentalScore?: number;
  };
  cwe: string[];
  references: string[];
  publishedDate: Date;
  lastModified: Date;
  affectedVersions: string[];
  patchedVersions: string[];
  exploitAvailable: boolean;
  exploitMaturity: 'unproven' | 'proof-of-concept' | 'functional' | 'high';
  recommendedAction: string;
  vendorAdvisory?: string;
}

export interface DependencyTree {
  package: PackageInfo;
  dependencies: DependencyTree[];
  vulnerabilities: Vulnerability[];
  riskScore: number;
  depth: number;
  isDirect: boolean;
}

export interface LicenseIssue {
  package: string;
  license: string;
  type: 'incompatible' | 'copyleft' | 'unknown' | 'deprecated';
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  description: string;
  recommendation: string;
}

export interface OutdatedPackage {
  package: string;
  currentVersion: string;
  latestVersion: string;
  majorVersionsBehind: number;
  securityUpdates: boolean;
  breakingChanges: boolean;
  updateRecommendation: 'immediate' | 'planned' | 'optional';
}

export interface SupplyChainRisk {
  package: string;
  riskType: 'maintainer_risk' | 'typosquatting' | 'dependency_confusion' | 'malicious_package';
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  description: string;
  indicators: string[];
  mitigation: string;
}

export interface DependencyScanResult {
  summary: {
    totalPackages: number;
    directDependencies: number;
    transitiveDependencies: number;
    vulnerablePackages: number;
    criticalVulnerabilities: number;
    highVulnerabilities: number;
    mediumVulnerabilities: number;
    lowVulnerabilities: number;
    outdatedPackages: number;
    licenseIssues: number;
    supplyChainRisks: number;
    overallRiskScore: number;
  };
  dependencyTree: DependencyTree[];
  vulnerabilities: Array<{
    package: string;
    version: string;
    vulnerability: Vulnerability;
    path: string[];
    fixAvailable: boolean;
    fixVersion?: string;
  }>;
  licenseIssues: LicenseIssue[];
  outdatedPackages: OutdatedPackage[];
  supplyChainRisks: SupplyChainRisk[];
  recommendations: Array<{
    priority: 'Critical' | 'High' | 'Medium' | 'Low';
    category: 'security' | 'maintenance' | 'license' | 'supply_chain';
    title: string;
    description: string;
    action: string;
    packages: string[];
  }>;
  scanMetadata: {
    scanDate: Date;
    scanDuration: number;
    databasesUsed: string[];
    toolVersion: string;
  };
}

export class DependencyVulnerabilityScanner {
  private vulnerabilityDatabases: VulnerabilityDatabase[] = [
    {
      name: 'National Vulnerability Database (NVD)',
      url: 'https://nvd.nist.gov/',
      lastUpdated: new Date(),
      totalVulnerabilities: 200000
    },
    {
      name: 'GitHub Advisory Database',
      url: 'https://github.com/advisories',
      lastUpdated: new Date(),
      totalVulnerabilities: 50000
    },
    {
      name: 'OSV (Open Source Vulnerabilities)',
      url: 'https://osv.dev/',
      lastUpdated: new Date(),
      totalVulnerabilities: 75000
    }
  ];

  private packageManagers = {
    npm: {
      lockfile: 'package-lock.json',
      manifest: 'package.json',
      registry: 'https://registry.npmjs.org/'
    },
    yarn: {
      lockfile: 'yarn.lock',
      manifest: 'package.json',
      registry: 'https://registry.yarnpkg.com/'
    },
    pip: {
      lockfile: 'requirements.txt',
      manifest: 'requirements.txt',
      registry: 'https://pypi.org/'
    },
    maven: {
      lockfile: 'pom.xml',
      manifest: 'pom.xml',
      registry: 'https://repo1.maven.org/maven2/'
    },
    gradle: {
      lockfile: 'build.gradle',
      manifest: 'build.gradle',
      registry: 'https://repo1.maven.org/maven2/'
    },
    composer: {
      lockfile: 'composer.lock',
      manifest: 'composer.json',
      registry: 'https://packagist.org/'
    },
    cargo: {
      lockfile: 'Cargo.lock',
      manifest: 'Cargo.toml',
      registry: 'https://crates.io/'
    },
    gem: {
      lockfile: 'Gemfile.lock',
      manifest: 'Gemfile',
      registry: 'https://rubygems.org/'
    }
  };

  private licenseCompatibility: Record<string, { type: 'permissive' | 'copyleft' | 'proprietary' | 'unknown'; compatible: boolean }> = {
    'MIT': { type: 'permissive', compatible: true },
    'Apache-2.0': { type: 'permissive', compatible: true },
    'BSD-3-Clause': { type: 'permissive', compatible: true },
    'GPL-3.0': { type: 'copyleft', compatible: false },
    'LGPL-3.0': { type: 'copyleft', compatible: true },
    'AGPL-3.0': { type: 'copyleft', compatible: false },
    'Proprietary': { type: 'proprietary', compatible: false },
    'UNLICENSED': { type: 'unknown', compatible: false }
  };

  /**
   * Scan dependencies for vulnerabilities
   */
  public async scanDependencies(files: Array<{ name: string; content: string }>): Promise<DependencyScanResult> {
    const startTime = Date.now();

    try {
      // Identify package manager files
      const packageFiles = this.identifyPackageFiles(files);
      
      // Parse dependency manifests
      const dependencyTree = await this.buildDependencyTree(packageFiles);
      
      // Scan for vulnerabilities
      const vulnerabilities = await this.scanForVulnerabilities(dependencyTree);
      
      // Check for license issues
      const licenseIssues = await this.analyzeLicenses(dependencyTree);
      
      // Find outdated packages
      const outdatedPackages = await this.findOutdatedPackages(dependencyTree);
      
      // Assess supply chain risks
      const supplyChainRisks = await this.assessSupplyChainRisks(dependencyTree);
      
      // Generate summary and recommendations
      const summary = this.generateSummary(dependencyTree, vulnerabilities, licenseIssues, outdatedPackages, supplyChainRisks);
      const recommendations = this.generateRecommendations(vulnerabilities, licenseIssues, outdatedPackages, supplyChainRisks);

      return {
        summary,
        dependencyTree,
        vulnerabilities,
        licenseIssues,
        outdatedPackages,
        supplyChainRisks,
        recommendations,
        scanMetadata: {
          scanDate: new Date(),
          scanDuration: Date.now() - startTime,
          databasesUsed: this.vulnerabilityDatabases.map(db => db.name),
          toolVersion: '1.0.0'
        }
      };
    } catch (error) {
      throw new Error(`Dependency scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private calculatePackageRiskScore(vulnerabilities: Vulnerability[]): number {
    let score = 0;
    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'Critical': score += 25; break;
        case 'High': score += 10; break;
        case 'Medium': score += 5; break;
        case 'Low': score += 1; break;
      }
    });
    return Math.min(100, score);
  }

  /**
   * Identify package manager files in the project
   */
  private identifyPackageFiles(files: Array<{ name: string; content: string }>) {
    const packageFiles: Array<{ 
      name: string; 
      content: string; 
      ecosystem: string; 
      type: 'manifest' | 'lockfile' 
    }> = [];

    files.forEach(file => {
      // Skip files without a name
      if (!file.name) return;
      
      const filename = file.name.toLowerCase();
      
      for (const [ecosystem, config] of Object.entries(this.packageManagers)) {
        if (filename.endsWith(config.manifest.toLowerCase())) {
          packageFiles.push({
            name: file.name,
            content: file.content,
            ecosystem,
            type: 'manifest'
          });
        } else if (filename.endsWith(config.lockfile.toLowerCase())) {
          packageFiles.push({
            name: file.name,
            content: file.content,
            ecosystem,
            type: 'lockfile'
          });
        }
      }
    });

    return packageFiles;
  }

  /**
   * Build dependency tree from package files
   */
  private async buildDependencyTree(packageFiles: Array<{ name: string; content: string; ecosystem: string; type: string }>): Promise<DependencyTree[]> {
    const dependencyTrees: DependencyTree[] = [];

    for (const file of packageFiles) {
      if (file.type === 'manifest') {
        const tree = await this.parseManifestFile(file);
        if (tree) {
          dependencyTrees.push(tree);
        }
      }
    }

    return dependencyTrees;
  }

  /**
   * Parse package manifest file
   */
  private async parseManifestFile(file: { name: string; content: string; ecosystem: string }): Promise<DependencyTree | null> {
    try {
      let dependencies: Record<string, string> = {};

      switch (file.ecosystem) {
        case 'npm':
        case 'yarn': {
          const packageJson = JSON.parse(file.content);
          dependencies = {
            ...packageJson.dependencies || {},
            ...packageJson.devDependencies || {},
            ...packageJson.peerDependencies || {}
          };
          break;
        }

        case 'pip': {
          const lines = file.content.split('\n');
          lines.forEach(line => {
            const match = line.trim().match(/^([a-zA-Z0-9_-]+)([><=!]+)?([\d.]+)?/);
            if (match) {
              dependencies[match[1]] = match[3] || 'latest';
            }
          });
          break;
        }

        case 'maven': {
          const dependencyMatches = file.content.match(/<dependency>[\s\S]*?<\/dependency>/g);
          if (dependencyMatches) {
            dependencyMatches.forEach(dep => {
              const groupMatch = dep.match(/<groupId>(.*?)<\/groupId>/);
              const artifactMatch = dep.match(/<artifactId>(.*?)<\/artifactId>/);
              const versionMatch = dep.match(/<version>(.*?)<\/version>/);
              if (groupMatch && artifactMatch) {
                const name = `${groupMatch[1]}:${artifactMatch[1]}`;
                dependencies[name] = versionMatch ? versionMatch[1] : 'latest';
              }
            });
          }
          break;
        }

        case 'composer': {
          const composerJson = JSON.parse(file.content);
          dependencies = {
            ...composerJson.require || {},
            ...composerJson['require-dev'] || {}
          };
          break;
        }

        case 'cargo': {
          const cargoLines = file.content.split('\n');
          let inDependencies = false;
          cargoLines.forEach(line => {
            if (line.trim() === '[dependencies]') {
              inDependencies = true;
              return;
            }
            if (line.trim().startsWith('[') && line.trim() !== '[dependencies]') {
              inDependencies = false;
              return;
            }
            if (inDependencies) {
              const match = line.match(/^([a-zA-Z0-9_-]+)\s*=\s*"([^"]+)"/);
              if (match) {
                dependencies[match[1]] = match[2];
              }
            }
          });
          break;
        }
      }

      // Create dependency tree structure
      const dependencyNodes: DependencyTree[] = [];
      
      for (const [name, versionRaw] of Object.entries(dependencies)) {
        const normalizedVersion = this.normalizeVersion(versionRaw);
        const packageInfo = await this.getPackageInfo(name, normalizedVersion, file.ecosystem);
        const vulnerabilities = await this.getPackageVulnerabilities(name, normalizedVersion, file.ecosystem);
        
        dependencyNodes.push({
          package: packageInfo,
          dependencies: [], // Transitive dependencies would be resolved recursively
          vulnerabilities,
          riskScore: this.calculatePackageRiskScore(vulnerabilities),
          depth: 1,
          isDirect: true
        });
      }

      return {
        package: {
          name: file.name,
          version: '1.0.0',
          ecosystem: file.ecosystem,
          description: 'Project root'
        },
        dependencies: dependencyNodes,
        vulnerabilities: [],
        riskScore: 0,
        depth: 0,
        isDirect: true
      };

    } catch {
      return null;
    }
  }

  /**
   * Get package information from registry
   */
  private async getPackageInfo(name: string, version: string, ecosystem: string): Promise<PackageInfo> {
    // In a real implementation, this would fetch from package registries
    return {
      name,
      version,
      ecosystem,
      description: `Package ${name}`,
      license: 'Unknown',
      deprecated: false
    };
  }

  /**
   * Get vulnerabilities for a specific package
   */
  private async getPackageVulnerabilities(name: string, version: string, _ecosystem: string): Promise<Vulnerability[]> {
    const results: Vulnerability[] = [];
    const osvEco = this.mapToOsvEcosystem(_ecosystem);
    if (!osvEco || !version || version === 'latest') {
      return results;
    }
    try {
      const res = await globalThis.fetch('https://api.osv.dev/v1/query', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ package: { name, ecosystem: osvEco }, version })
      });
      if (!res.ok) return results;
      const data = await res.json();
      const vulns = Array.isArray(data.vulns) ? data.vulns : Array.isArray(data.vulnerabilities) ? data.vulnerabilities : [];
      for (const v of vulns) {
        const score = this.extractCvssScore(v);
        const severity = this.cvssToSeverity(score);
        const refs = Array.isArray(v.references) ? v.references.map((r: { url?: string }) => r.url).filter(Boolean) as string[] : [];
        results.push({
          id: v.id || v.database_specific?.id || 'UNKNOWN',
          title: v.summary || v.details?.slice(0, 120) || 'Vulnerability',
          description: v.details || v.summary || 'See references',
          severity,
          cvss: {
            version: '3.x',
            score,
            vector: '',
            baseScore: score
          },
          cwe: Array.isArray(v.credits) ? [] : [],
          references: refs,
          publishedDate: v.published ? new Date(v.published) : new Date(),
          lastModified: v.modified ? new Date(v.modified) : new Date(),
          affectedVersions: [],
          patchedVersions: [],
          exploitAvailable: false,
          exploitMaturity: 'unproven',
          recommendedAction: 'Update to a non-affected version',
          vendorAdvisory: refs[0]
        });
      }
    } catch {
      return results;
    }
    return results;
  }

  /**
   * Scan all dependencies for vulnerabilities
   */
  private async scanForVulnerabilities(dependencyTrees: DependencyTree[]): Promise<Array<{
    package: string;
    version: string;
    vulnerability: Vulnerability;
    path: string[];
    fixAvailable: boolean;
    fixVersion?: string;
  }>> {
    const vulnerabilities: Array<{
      package: string;
      version: string;
      vulnerability: Vulnerability;
      path: string[];
      fixAvailable: boolean;
      fixVersion?: string;
    }> = [];

    const scanTree = (tree: DependencyTree, path: string[] = []) => {
      tree.vulnerabilities.forEach(vuln => {
        vulnerabilities.push({
          package: tree.package.name,
          version: tree.package.version,
          vulnerability: vuln,
          path: [...path, tree.package.name],
          fixAvailable: vuln.patchedVersions.length > 0,
          fixVersion: vuln.patchedVersions[0]
        });
      });

      tree.dependencies.forEach(dep => {
        scanTree(dep, [...path, tree.package.name]);
      });
    };

    dependencyTrees.forEach(tree => scanTree(tree));
    return vulnerabilities;
  }

  /**
   * Analyze license compatibility
   */
  private async analyzeLicenses(dependencyTrees: DependencyTree[]): Promise<LicenseIssue[]> {
    const licenseIssues: LicenseIssue[] = [];

    const checkLicenses = (tree: DependencyTree) => {
      const license = tree.package.license;
      if (license) {
        const compatibility = this.licenseCompatibility[license];
        if (compatibility && !compatibility.compatible) {
          licenseIssues.push({
            package: tree.package.name,
            license,
            type: compatibility.type === 'copyleft' ? 'copyleft' : 'incompatible',
            severity: compatibility.type === 'copyleft' ? 'Medium' : 'High',
            description: `Package uses ${license} license which may have compatibility issues`,
            recommendation: `Review license terms and consider alternatives`
          });
        }
      }

      tree.dependencies.forEach(dep => checkLicenses(dep));
    };

    dependencyTrees.forEach(tree => checkLicenses(tree));
    return licenseIssues;
  }

  /**
   * Find outdated packages
   */
  private async findOutdatedPackages(dependencyTrees: DependencyTree[]): Promise<OutdatedPackage[]> {
    const outdatedPackages: OutdatedPackage[] = [];
    const getLatestVersion = async (ecosystem: string, name: string): Promise<string> => {
      try {
        switch (ecosystem) {
          case 'npm':
          case 'yarn': {
            const res = await globalThis.fetch(`https://registry.npmjs.org/${encodeURIComponent(name)}`);
            if (!res.ok) return '';
            const data = await res.json();
            return data['dist-tags']?.latest || data?.version || '';
          }
          case 'pip': {
            const res = await globalThis.fetch(`https://pypi.org/pypi/${encodeURIComponent(name)}/json`);
            if (!res.ok) return '';
            const data = await res.json();
            return data?.info?.version || '';
          }
          case 'maven':
          case 'gradle': {
            // name is "group:artifact"
            const [group, artifact] = name.split(':');
            if (!group || !artifact) return '';
            const q = `g:"${group}" AND a:"${artifact}"`;
            const res = await globalThis.fetch(`https://search.maven.org/solrsearch/select?q=${encodeURIComponent(q)}&rows=1&wt=json`);
            if (!res.ok) return '';
            const data = await res.json();
            return data?.response?.docs?.[0]?.latestVersion || '';
          }
          case 'composer': {
            // vendor/package
            if (!name.includes('/')) return '';
            const res = await globalThis.fetch(`https://repo.packagist.org/p2/${name}.json`);
            if (!res.ok) return '';
            const data = await res.json();
            const list = (data?.packages?.[name] as Array<{ version?: string }> | undefined);
            if (Array.isArray(list) && list.length) {
              // Prefer first stable version entry
              const stable = list.find((v) => typeof v.version === 'string' && !/dev|alpha|beta|rc/i.test(v.version as string));
              return stable?.version || list[0].version || '';
            }
            return '';
          }
          case 'cargo': {
            const res = await globalThis.fetch(`https://crates.io/api/v1/crates/${encodeURIComponent(name)}`);
            if (!res.ok) return '';
            const data = await res.json();
            return data?.crate?.max_stable_version || data?.crate?.max_version || '';
          }
          case 'gem': {
            const res = await globalThis.fetch(`https://rubygems.org/api/v1/gems/${encodeURIComponent(name)}.json`);
            if (!res.ok) return '';
            const data = await res.json();
            return data?.version || '';
          }
          default:
            return '';
        }
      } catch {
        return '';
      }
    };

    const pushIfOutdated = (pkg: string, current: string, latest: string) => {
      if (!latest) return;
      const diff = this.majorDiff(current, latest);
      if (diff >= 0) {
        outdatedPackages.push({
          package: pkg,
          currentVersion: current,
          latestVersion: latest,
          majorVersionsBehind: diff,
          securityUpdates: true,
          breakingChanges: diff > 0,
          updateRecommendation: diff >= 1 ? 'planned' : 'optional'
        });
      }
    };

    const walk = async (tree: DependencyTree) => {
      // Skip pseudo root nodes (depth 0) representing manifests
      if (tree.depth > 0 && tree.package.name && tree.package.version && tree.package.ecosystem) {
        const eco = tree.package.ecosystem;
        const current = this.normalizeVersion(tree.package.version);
        const latest = await getLatestVersion(eco, tree.package.name);
        pushIfOutdated(tree.package.name, current || tree.package.version, latest);
      }
      for (const dep of tree.dependencies) await walk(dep);
    };

    for (const t of dependencyTrees) await walk(t);
    return outdatedPackages;
  }

  /**
   * Assess supply chain security risks
   */
  private async assessSupplyChainRisks(dependencyTrees: DependencyTree[]): Promise<SupplyChainRisk[]> {
    const risks: SupplyChainRisk[] = [];

    const assessTree = (tree: DependencyTree) => {
      // Check for typosquatting risks
      if (this.isPotentialTyposquat(tree.package.name)) {
        risks.push({
          package: tree.package.name,
          riskType: 'typosquatting',
          severity: 'Medium',
          description: 'Package name resembles a popular package',
          indicators: ['Similar name to popular package'],
          mitigation: 'Verify package authenticity and author'
        });
      }

      // Check for suspicious maintainer patterns
      if (tree.package.maintainers && tree.package.maintainers.length === 1) {
        risks.push({
          package: tree.package.name,
          riskType: 'maintainer_risk',
          severity: 'Low',
          description: 'Package has only one maintainer',
          indicators: ['Single maintainer', 'Bus factor of 1'],
          mitigation: 'Monitor package for maintenance issues'
        });
      }

      tree.dependencies.forEach(dep => assessTree(dep));
    };

    dependencyTrees.forEach(tree => assessTree(tree));
    return risks;
  }

  /**
   * Generate scan summary
   */
  private generateSummary(
    dependencyTrees: DependencyTree[],
    vulnerabilities: Array<{ package: string; vulnerability?: Vulnerability }>,
    licenseIssues: LicenseIssue[],
    outdatedPackages: OutdatedPackage[],
    supplyChainRisks: SupplyChainRisk[]
  ) {
    let totalPackages = 0;
    let directDependencies = 0;

    const countPackages = (tree: DependencyTree) => {
      totalPackages++;
      if (tree.isDirect) directDependencies++;
      tree.dependencies.forEach(dep => countPackages(dep));
    };

    dependencyTrees.forEach(tree => countPackages(tree));

    const criticalVulns = vulnerabilities.filter(v => v.vulnerability?.severity === 'Critical').length;
    const highVulns = vulnerabilities.filter(v => v.vulnerability?.severity === 'High').length;
    const mediumVulns = vulnerabilities.filter(v => v.vulnerability?.severity === 'Medium').length;
    const lowVulns = vulnerabilities.filter(v => v.vulnerability?.severity === 'Low').length;

    const overallRiskScore = Math.min(100, 
      (criticalVulns * 25) + (highVulns * 10) + (mediumVulns * 5) + (lowVulns * 1)
    );

    return {
      totalPackages,
      directDependencies,
      transitiveDependencies: totalPackages - directDependencies,
      vulnerablePackages: new Set(vulnerabilities.map(v => v.package)).size,
      criticalVulnerabilities: criticalVulns,
      highVulnerabilities: highVulns,
      mediumVulnerabilities: mediumVulns,
      lowVulnerabilities: lowVulns,
      outdatedPackages: outdatedPackages.length,
      licenseIssues: licenseIssues.length,
      supplyChainRisks: supplyChainRisks.length,
      overallRiskScore
    };
  }

  private generateRecommendations(
    vulnerabilities: Array<{ package: string; vulnerability: { severity: 'Critical' | 'High' | 'Medium' | 'Low' } }>,
    licenseIssues: LicenseIssue[],
    outdatedPackages: OutdatedPackage[],
    supplyChainRisks: SupplyChainRisk[]
  ) {
    const recommendations: Array<{
      priority: 'Critical' | 'High' | 'Medium' | 'Low';
      category: 'security' | 'maintenance' | 'license' | 'supply_chain';
      title: string;
      description: string;
      action: string;
      packages: string[];
    }> = [];

    if (vulnerabilities.length > 0) {
      const criticalVulns = vulnerabilities.filter(v => v.vulnerability.severity === 'Critical');
      if (criticalVulns.length > 0) {
        recommendations.push({
          priority: 'Critical',
          category: 'security',
          title: 'Critical vulnerabilities found',
          description: `${criticalVulns.length} critical vulnerabilities detected`,
          action: 'Update vulnerable packages immediately',
          packages: criticalVulns.map(v => v.package)
        });
      }
    }

    if (licenseIssues.length > 0) {
      recommendations.push({
        priority: 'Medium',
        category: 'license',
        title: 'License compatibility issues',
        description: `${licenseIssues.length} packages have license issues`,
        action: 'Review license compatibility for compliance',
        packages: licenseIssues.map(l => l.package)
      });
    }

    if (outdatedPackages.length > 0) {
      recommendations.push({
        priority: 'Low',
        category: 'maintenance',
        title: 'Outdated packages detected',
        description: `${outdatedPackages.length} packages are behind latest versions`,
        action: 'Plan upgrades to latest stable versions',
        packages: outdatedPackages.map(o => o.package)
      });
    }

    if (supplyChainRisks.length > 0) {
      recommendations.push({
        priority: 'Medium',
        category: 'supply_chain',
        title: 'Supply chain risks identified',
        description: `${supplyChainRisks.length} potential risks in supply chain`,
        action: 'Verify package authenticity and maintainers',
        packages: supplyChainRisks.map(r => r.package)
      });
    }

    return recommendations;
  }

  private normalizeVersion(input: string): string {
    if (!input) return '';
    let v = String(input).trim();
    v = v.replace(/^[\^~><= ]+/, '');
    if (v === '*' || v.toLowerCase() === 'latest' || v.toLowerCase() === 'x') return '';
    const m = v.match(/\d+\.\d+\.\d+/);
    return m ? m[0] : v;
  }

  private majorDiff(current: string, latest: string): number {
    const c = (this.normalizeVersion(current) || '0.0.0').split('.').map(n => parseInt(n || '0', 10));
    const l = (this.normalizeVersion(latest) || '0.0.0').split('.').map(n => parseInt(n || '0', 10));
    if (l[0] !== c[0]) return Math.max(0, l[0] - c[0]);
    return 0;
  }

  private mapToOsvEcosystem(ecosystem: string): string | null {
    switch (ecosystem) {
      case 'npm':
      case 'yarn':
        return 'npm';
      case 'pip':
        return 'PyPI';
      case 'maven':
      case 'gradle':
        return 'Maven';
      case 'composer':
        return 'Packagist';
      case 'cargo':
        return 'crates.io';
      case 'gem':
        return 'RubyGems';
      default:
        return null;
    }
  }

  private extractCvssScore(v: unknown): number {
    const vv = v as { severity?: Array<{ score: string }> };
    if (Array.isArray(vv.severity) && vv.severity.length > 0) {
      const scoreStr = vv.severity[0].score;
      const n = parseFloat(scoreStr);
      if (!Number.isNaN(n)) return n;
    }
    return 0;
  }

  private cvssToSeverity(score: number): 'Critical' | 'High' | 'Medium' | 'Low' {
    if (score >= 9) return 'Critical';
    if (score >= 7) return 'High';
    if (score >= 4) return 'Medium';
    return 'Low';
  }

  private isPotentialTyposquat(packageName: string): boolean {
    const popularPackages = [
      'react', 'lodash', 'express', 'axios', 'webpack', 'babel',
      'eslint', 'prettier', 'typescript', 'node', 'npm', 'yarn'
    ];
    return popularPackages.some(popular => 
      this.levenshteinDistance(packageName.toLowerCase(), popular) <= 2 && 
      packageName.toLowerCase() !== popular
    );
  }

  private levenshteinDistance(str1: string, str2: string): number {
    const matrix: number[][] = [];
    for (let i = 0; i <= str2.length; i++) matrix[i] = [i];
    for (let j = 0; j <= str1.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    return matrix[str2.length][str1.length];
  }
}