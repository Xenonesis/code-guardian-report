/**
 * Vulnerability Aggregation Service
 * Aggregates and analyzes vulnerability patterns from real security scan results
 * stored in Firebase. This replaces estimated/random data with actual analysis data.
 */

import { SecurityIssue } from "@/hooks/useAnalysis";
import { logger } from "@/utils/logger";

export interface VulnerabilityPattern {
  type: string;
  count: number;
  severity: "critical" | "high" | "medium" | "low";
  trend: "increasing" | "stable" | "decreasing";
  affectedRepos: number;
  affectedFiles: Set<string>;
  description: string;
  cweIds: string[];
  owaspCategories: string[];
}

export interface LanguageVulnerability {
  language: string;
  vulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  mostCommon: string;
  patterns: Map<string, number>;
}

export interface TrendingVulnerability {
  name: string;
  occurrences: number;
  trend: number; // percentage change
  severity: "critical" | "high" | "medium" | "low";
  cweId?: string;
  recentOccurrences: number;
}

export interface AggregatedVulnerabilityData {
  patterns: VulnerabilityPattern[];
  languageVulnerabilities: LanguageVulnerability[];
  trendingVulnerabilities: TrendingVulnerability[];
  totalVulnerabilities: number;
  severityDistribution: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
}

export interface CodeQualityMetrics {
  complexity: {
    average: number;
    max: number;
    files: number;
  };
  maintainability: {
    index: number;
    codeSmells: number;
    technicalDebtMinutes: number;
  };
  testCoverage: {
    percentage: number;
    linesTotal: number;
    linesCovered: number;
    hasTests: boolean;
  };
  documentation: {
    coverage: number;
    filesWithDocs: number;
    totalFiles: number;
  };
  duplication: {
    percentage: number;
    duplicatedBlocks: number;
  };
}

// Map security issue types/categories to vulnerability pattern types
const VULNERABILITY_PATTERN_MAP: Record<
  string,
  { type: string; description: string }
> = {
  // Injection vulnerabilities
  "sql-injection": {
    type: "Injection Vulnerabilities",
    description: "SQL, NoSQL, Command injection vulnerabilities",
  },
  "command-injection": {
    type: "Injection Vulnerabilities",
    description: "SQL, NoSQL, Command injection vulnerabilities",
  },
  "code-injection": {
    type: "Injection Vulnerabilities",
    description: "SQL, NoSQL, Command injection vulnerabilities",
  },
  "ldap-injection": {
    type: "Injection Vulnerabilities",
    description: "SQL, NoSQL, Command injection vulnerabilities",
  },
  "xpath-injection": {
    type: "Injection Vulnerabilities",
    description: "SQL, NoSQL, Command injection vulnerabilities",
  },
  "nosql-injection": {
    type: "Injection Vulnerabilities",
    description: "SQL, NoSQL, Command injection vulnerabilities",
  },

  // Authentication issues
  "weak-authentication": {
    type: "Authentication Issues",
    description: "Weak authentication, session management issues",
  },
  "hardcoded-credentials": {
    type: "Authentication Issues",
    description: "Weak authentication, session management issues",
  },
  "weak-password": {
    type: "Authentication Issues",
    description: "Weak authentication, session management issues",
  },
  "session-fixation": {
    type: "Authentication Issues",
    description: "Weak authentication, session management issues",
  },
  "broken-authentication": {
    type: "Authentication Issues",
    description: "Weak authentication, session management issues",
  },

  // XSS vulnerabilities
  xss: {
    type: "XSS Vulnerabilities",
    description: "Cross-site scripting vulnerabilities",
  },
  "cross-site-scripting": {
    type: "XSS Vulnerabilities",
    description: "Cross-site scripting vulnerabilities",
  },
  "reflected-xss": {
    type: "XSS Vulnerabilities",
    description: "Cross-site scripting vulnerabilities",
  },
  "stored-xss": {
    type: "XSS Vulnerabilities",
    description: "Cross-site scripting vulnerabilities",
  },
  "dom-xss": {
    type: "XSS Vulnerabilities",
    description: "Cross-site scripting vulnerabilities",
  },

  // Dependency vulnerabilities
  "vulnerable-dependency": {
    type: "Insecure Dependencies",
    description: "Outdated or vulnerable third-party packages",
  },
  "outdated-dependency": {
    type: "Insecure Dependencies",
    description: "Outdated or vulnerable third-party packages",
  },
  dependency: {
    type: "Insecure Dependencies",
    description: "Outdated or vulnerable third-party packages",
  },

  // Sensitive data exposure
  "sensitive-data": {
    type: "Sensitive Data Exposure",
    description: "Exposed secrets, API keys, credentials",
  },
  "secret-exposure": {
    type: "Sensitive Data Exposure",
    description: "Exposed secrets, API keys, credentials",
  },
  "api-key-exposure": {
    type: "Sensitive Data Exposure",
    description: "Exposed secrets, API keys, credentials",
  },
  "credential-exposure": {
    type: "Sensitive Data Exposure",
    description: "Exposed secrets, API keys, credentials",
  },
  "information-disclosure": {
    type: "Sensitive Data Exposure",
    description: "Exposed secrets, API keys, credentials",
  },

  // CSRF vulnerabilities
  csrf: {
    type: "CSRF Vulnerabilities",
    description: "Cross-site request forgery issues",
  },
  "cross-site-request-forgery": {
    type: "CSRF Vulnerabilities",
    description: "Cross-site request forgery issues",
  },

  // Configuration issues
  misconfiguration: {
    type: "Insecure Configuration",
    description: "Security misconfigurations, default settings",
  },
  "security-misconfiguration": {
    type: "Insecure Configuration",
    description: "Security misconfigurations, default settings",
  },
  "insecure-defaults": {
    type: "Insecure Configuration",
    description: "Security misconfigurations, default settings",
  },
  "debug-enabled": {
    type: "Insecure Configuration",
    description: "Security misconfigurations, default settings",
  },

  // Cryptography issues
  "weak-cryptography": {
    type: "Weak Cryptography",
    description: "Weak or outdated cryptographic algorithms",
  },
  "insecure-random": {
    type: "Weak Cryptography",
    description: "Weak or outdated cryptographic algorithms",
  },
  "weak-hash": {
    type: "Weak Cryptography",
    description: "Weak or outdated cryptographic algorithms",
  },
  "weak-cipher": {
    type: "Weak Cryptography",
    description: "Weak or outdated cryptographic algorithms",
  },

  // Access control
  "broken-access-control": {
    type: "Broken Access Control",
    description: "Authorization and access control issues",
  },
  idor: {
    type: "Broken Access Control",
    description: "Authorization and access control issues",
  },
  "privilege-escalation": {
    type: "Broken Access Control",
    description: "Authorization and access control issues",
  },
  "path-traversal": {
    type: "Broken Access Control",
    description: "Authorization and access control issues",
  },

  // Deserialization
  "insecure-deserialization": {
    type: "Insecure Deserialization",
    description: "Unsafe deserialization of data",
  },
  "unsafe-deserialization": {
    type: "Insecure Deserialization",
    description: "Unsafe deserialization of data",
  },

  // SSRF
  ssrf: {
    type: "Server-Side Request Forgery",
    description: "SSRF vulnerabilities allowing internal network access",
  },
  "server-side-request-forgery": {
    type: "Server-Side Request Forgery",
    description: "SSRF vulnerabilities allowing internal network access",
  },

  // XXE
  xxe: {
    type: "XML External Entity",
    description: "XML External Entity injection vulnerabilities",
  },
  "xml-external-entity": {
    type: "XML External Entity",
    description: "XML External Entity injection vulnerabilities",
  },
};

export class VulnerabilityAggregationService {
  /**
   * Aggregate security issues from multiple repositories/analyses into vulnerability patterns
   */
  public aggregateVulnerabilities(
    analysisResults: Array<{
      repositoryName: string;
      language: string;
      issues: SecurityIssue[];
      analyzedAt: Date;
    }>,
    historicalResults?: Array<{
      repositoryName: string;
      issues: SecurityIssue[];
      analyzedAt: Date;
    }>
  ): AggregatedVulnerabilityData {
    try {
      const patterns = this.extractPatterns(analysisResults);
      const languageVulns = this.analyzeByLanguage(analysisResults);
      const trending = this.identifyTrending(
        analysisResults,
        historicalResults
      );
      const severityDist = this.calculateSeverityDistribution(analysisResults);
      const total = analysisResults.reduce(
        (sum, r) => sum + r.issues.length,
        0
      );

      return {
        patterns,
        languageVulnerabilities: languageVulns,
        trendingVulnerabilities: trending,
        totalVulnerabilities: total,
        severityDistribution: severityDist,
      };
    } catch (error) {
      logger.error("Error aggregating vulnerabilities:", error);
      return {
        patterns: [],
        languageVulnerabilities: [],
        trendingVulnerabilities: [],
        totalVulnerabilities: 0,
        severityDistribution: { critical: 0, high: 0, medium: 0, low: 0 },
      };
    }
  }

  /**
   * Extract vulnerability patterns from security issues
   */
  private extractPatterns(
    analysisResults: Array<{
      repositoryName: string;
      issues: SecurityIssue[];
    }>
  ): VulnerabilityPattern[] {
    const patternMap = new Map<string, VulnerabilityPattern>();

    for (const result of analysisResults) {
      for (const issue of result.issues) {
        const patternInfo = this.getPatternType(issue);

        if (!patternMap.has(patternInfo.type)) {
          patternMap.set(patternInfo.type, {
            type: patternInfo.type,
            count: 0,
            severity: this.normalizeSeverity(issue.severity),
            trend: "stable",
            affectedRepos: 0,
            affectedFiles: new Set(),
            description: patternInfo.description,
            cweIds: [],
            owaspCategories: [],
          });
        }

        const pattern = patternMap.get(patternInfo.type)!;
        pattern.count++;
        pattern.affectedFiles.add(`${result.repositoryName}:${issue.filename}`);

        // Track highest severity
        if (
          this.severityWeight(issue.severity) >
          this.severityWeight(pattern.severity)
        ) {
          pattern.severity = this.normalizeSeverity(issue.severity);
        }

        // Collect CWE/OWASP references
        if (issue.cweId && !pattern.cweIds.includes(issue.cweId)) {
          pattern.cweIds.push(issue.cweId);
        }
        if (
          issue.owaspCategory &&
          !pattern.owaspCategories.includes(issue.owaspCategory)
        ) {
          pattern.owaspCategories.push(issue.owaspCategory);
        }
      }
    }

    // Calculate affected repos for each pattern
    for (const pattern of patternMap.values()) {
      const repos = new Set<string>();
      for (const file of pattern.affectedFiles) {
        const repoName = file.split(":")[0];
        repos.add(repoName);
      }
      pattern.affectedRepos = repos.size;
    }

    return Array.from(patternMap.values())
      .filter((p) => p.count > 0)
      .sort((a, b) => b.count - a.count);
  }

  /**
   * Analyze vulnerabilities by programming language
   */
  private analyzeByLanguage(
    analysisResults: Array<{
      repositoryName: string;
      language: string;
      issues: SecurityIssue[];
    }>
  ): LanguageVulnerability[] {
    const languageMap = new Map<string, LanguageVulnerability>();

    for (const result of analysisResults) {
      const lang = result.language || "Unknown";

      if (!languageMap.has(lang)) {
        languageMap.set(lang, {
          language: lang,
          vulnerabilities: 0,
          criticalCount: 0,
          highCount: 0,
          mediumCount: 0,
          lowCount: 0,
          mostCommon: "",
          patterns: new Map(),
        });
      }

      const langData = languageMap.get(lang)!;

      for (const issue of result.issues) {
        langData.vulnerabilities++;

        // Count by severity
        const severity = issue.severity.toLowerCase();
        if (severity === "critical") langData.criticalCount++;
        else if (severity === "high") langData.highCount++;
        else if (severity === "medium") langData.mediumCount++;
        else langData.lowCount++;

        // Track patterns for this language
        const patternType = this.getPatternType(issue).type;
        langData.patterns.set(
          patternType,
          (langData.patterns.get(patternType) || 0) + 1
        );
      }
    }

    // Determine most common pattern for each language
    for (const langData of languageMap.values()) {
      let maxCount = 0;
      let mostCommon = "N/A";
      for (const [pattern, count] of langData.patterns) {
        if (count > maxCount) {
          maxCount = count;
          mostCommon = pattern;
        }
      }
      langData.mostCommon = mostCommon;
    }

    return Array.from(languageMap.values())
      .filter((l) => l.vulnerabilities > 0)
      .sort((a, b) => b.vulnerabilities - a.vulnerabilities);
  }

  /**
   * Identify trending vulnerabilities based on recent vs historical data
   */
  private identifyTrending(
    recentResults: Array<{
      repositoryName: string;
      issues: SecurityIssue[];
      analyzedAt: Date;
    }>,
    historicalResults?: Array<{
      repositoryName: string;
      issues: SecurityIssue[];
      analyzedAt: Date;
    }>
  ): TrendingVulnerability[] {
    // Count recent occurrences by issue type
    const recentCounts = new Map<
      string,
      { count: number; severity: string; cweId?: string }
    >();

    for (const result of recentResults) {
      for (const issue of result.issues) {
        const key = issue.type || issue.category || "Unknown";
        const existing = recentCounts.get(key) || {
          count: 0,
          severity: issue.severity,
          cweId: issue.cweId,
        };
        existing.count++;
        recentCounts.set(key, existing);
      }
    }

    // Count historical occurrences if available
    const historicalCounts = new Map<string, number>();
    if (historicalResults && historicalResults.length > 0) {
      for (const result of historicalResults) {
        for (const issue of result.issues) {
          const key = issue.type || issue.category || "Unknown";
          historicalCounts.set(key, (historicalCounts.get(key) || 0) + 1);
        }
      }
    }

    // Calculate trends
    const trending: TrendingVulnerability[] = [];

    for (const [name, data] of recentCounts) {
      const historicalCount = historicalCounts.get(name) || data.count;
      const trend =
        historicalCount > 0
          ? Math.round(((data.count - historicalCount) / historicalCount) * 100)
          : 0;

      trending.push({
        name: this.formatVulnerabilityName(name),
        occurrences: data.count,
        trend,
        severity: this.normalizeSeverity(data.severity),
        cweId: data.cweId,
        recentOccurrences: data.count,
      });
    }

    return trending.sort((a, b) => b.occurrences - a.occurrences).slice(0, 8); // Top 8 trending vulnerabilities
  }

  /**
   * Calculate severity distribution
   */
  private calculateSeverityDistribution(
    analysisResults: Array<{ issues: SecurityIssue[] }>
  ): { critical: number; high: number; medium: number; low: number } {
    const distribution = { critical: 0, high: 0, medium: 0, low: 0 };

    for (const result of analysisResults) {
      for (const issue of result.issues) {
        const severity = issue.severity.toLowerCase();
        if (severity === "critical") distribution.critical++;
        else if (severity === "high") distribution.high++;
        else if (severity === "medium") distribution.medium++;
        else distribution.low++;
      }
    }

    return distribution;
  }

  /**
   * Calculate code quality metrics from analysis results
   */
  public calculateQualityMetrics(
    analysisResults: Array<{
      repositoryName: string;
      issues: SecurityIssue[];
      metrics?: {
        totalLines?: number;
        totalFiles?: number;
        codeComplexity?: number;
        maintainabilityIndex?: number;
        testCoverage?: number;
        duplicatedLines?: number;
      };
    }>
  ): CodeQualityMetrics {
    const defaultMetrics: CodeQualityMetrics = {
      complexity: { average: 0, max: 0, files: 0 },
      maintainability: { index: 0, codeSmells: 0, technicalDebtMinutes: 0 },
      testCoverage: {
        percentage: 0,
        linesTotal: 0,
        linesCovered: 0,
        hasTests: false,
      },
      documentation: { coverage: 0, filesWithDocs: 0, totalFiles: 0 },
      duplication: { percentage: 0, duplicatedBlocks: 0 },
    };

    if (analysisResults.length === 0) {
      return defaultMetrics;
    }

    let totalComplexity = 0;
    let maxComplexity = 0;
    let totalFiles = 0;
    let totalMaintainability = 0;
    let totalCodeSmells = 0;
    let totalLines = 0;
    let totalCoveredLines = 0;
    let totalTestCoverage = 0;
    let hasTestsCount = 0;
    let totalDuplication = 0;

    for (const result of analysisResults) {
      const metrics = result.metrics || {};

      // Complexity
      const complexity = metrics.codeComplexity || 0;
      totalComplexity += complexity;
      maxComplexity = Math.max(maxComplexity, complexity);
      totalFiles += metrics.totalFiles || 0;

      // Maintainability
      totalMaintainability += metrics.maintainabilityIndex || 0;

      // Count code smells from issues
      const codeSmells = result.issues.filter(
        (i) =>
          i.type === "code-quality" ||
          i.category?.toLowerCase().includes("smell")
      ).length;
      totalCodeSmells += codeSmells;

      // Lines and coverage
      const lines = metrics.totalLines || 0;
      totalLines += lines;
      if (metrics.testCoverage !== undefined) {
        totalTestCoverage += metrics.testCoverage;
        totalCoveredLines += Math.round(lines * (metrics.testCoverage / 100));
        if (metrics.testCoverage > 0) hasTestsCount++;
      }

      // Duplication
      totalDuplication += metrics.duplicatedLines || 0;
    }

    const count = analysisResults.length;
    const avgComplexity = count > 0 ? totalComplexity / count : 0;
    const avgMaintainability = count > 0 ? totalMaintainability / count : 0;
    const avgTestCoverage = count > 0 ? totalTestCoverage / count : 0;
    const avgDuplication =
      totalLines > 0 ? (totalDuplication / totalLines) * 100 : 0;

    // Calculate technical debt: ~30 minutes per issue
    const calculateTechnicalDebt = (): number => {
      let debt = 0;
      for (const r of analysisResults) {
        for (const issue of r.issues) {
          if (issue.severity === "Critical") debt += 120;
          else if (issue.severity === "High") debt += 60;
          else if (issue.severity === "Medium") debt += 30;
          else debt += 15;
        }
      }
      return debt;
    };

    return {
      complexity: {
        average: Math.round(avgComplexity * 10) / 10,
        max: maxComplexity,
        files: totalFiles,
      },
      maintainability: {
        index: Math.round(avgMaintainability),
        codeSmells: totalCodeSmells,
        technicalDebtMinutes: calculateTechnicalDebt(),
      },
      testCoverage: {
        percentage: Math.round(avgTestCoverage),
        linesTotal: totalLines,
        linesCovered: totalCoveredLines,
        hasTests: hasTestsCount > 0,
      },
      documentation: {
        coverage: 0, // Would need separate doc analysis
        filesWithDocs: 0,
        totalFiles: totalFiles,
      },
      duplication: {
        percentage: Math.round(avgDuplication * 10) / 10,
        duplicatedBlocks: 0, // Would need block-level analysis
      },
    };
  }

  /**
   * Get pattern type from a security issue
   */
  private getPatternType(issue: SecurityIssue): {
    type: string;
    description: string;
  } {
    // Check direct type match
    const typeKey = (issue.type || "").toLowerCase().replace(/\s+/g, "-");
    if (VULNERABILITY_PATTERN_MAP[typeKey]) {
      return VULNERABILITY_PATTERN_MAP[typeKey];
    }

    // Check category match
    const categoryKey = (issue.category || "")
      .toLowerCase()
      .replace(/\s+/g, "-");
    if (VULNERABILITY_PATTERN_MAP[categoryKey]) {
      return VULNERABILITY_PATTERN_MAP[categoryKey];
    }

    // Check OWASP category
    const owaspKey = (issue.owaspCategory || "").toLowerCase();
    if (owaspKey.includes("injection")) {
      return VULNERABILITY_PATTERN_MAP["sql-injection"];
    }
    if (owaspKey.includes("authentication") || owaspKey.includes("auth")) {
      return VULNERABILITY_PATTERN_MAP["weak-authentication"];
    }
    if (owaspKey.includes("xss") || owaspKey.includes("cross-site scripting")) {
      return VULNERABILITY_PATTERN_MAP["xss"];
    }
    if (owaspKey.includes("sensitive") || owaspKey.includes("exposure")) {
      return VULNERABILITY_PATTERN_MAP["sensitive-data"];
    }
    if (owaspKey.includes("misconfiguration") || owaspKey.includes("config")) {
      return VULNERABILITY_PATTERN_MAP["misconfiguration"];
    }
    if (owaspKey.includes("component") || owaspKey.includes("dependency")) {
      return VULNERABILITY_PATTERN_MAP["vulnerable-dependency"];
    }

    // Check message for keywords
    const message = (issue.message || "").toLowerCase();
    if (message.includes("sql") || message.includes("injection")) {
      return VULNERABILITY_PATTERN_MAP["sql-injection"];
    }
    if (message.includes("xss") || message.includes("script")) {
      return VULNERABILITY_PATTERN_MAP["xss"];
    }
    if (
      message.includes("password") ||
      message.includes("credential") ||
      message.includes("secret")
    ) {
      return VULNERABILITY_PATTERN_MAP["sensitive-data"];
    }
    if (
      message.includes("dependency") ||
      message.includes("package") ||
      message.includes("outdated")
    ) {
      return VULNERABILITY_PATTERN_MAP["vulnerable-dependency"];
    }

    // Default to a generic category
    return {
      type: "Other Security Issues",
      description: "Miscellaneous security concerns",
    };
  }

  /**
   * Normalize severity to lowercase type
   */
  private normalizeSeverity(
    severity: string
  ): "critical" | "high" | "medium" | "low" {
    const s = (severity || "low").toLowerCase();
    if (s === "critical") return "critical";
    if (s === "high") return "high";
    if (s === "medium") return "medium";
    return "low";
  }

  /**
   * Get numeric weight for severity comparison
   */
  private severityWeight(severity: string): number {
    const s = (severity || "").toLowerCase();
    if (s === "critical") return 4;
    if (s === "high") return 3;
    if (s === "medium") return 2;
    if (s === "low") return 1;
    return 0;
  }

  /**
   * Format vulnerability name for display
   */
  private formatVulnerabilityName(name: string): string {
    return name
      .replace(/-/g, " ")
      .replace(/_/g, " ")
      .split(" ")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(" ");
  }
}

// Singleton instance
export const vulnerabilityAggregationService =
  new VulnerabilityAggregationService();
